<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="/images/favicon.png" />
<title>bkmr reborn | sysid blog</title>
<meta name="title" content="bkmr reborn" />
<meta name="description" content="Streamlining Developer Productivity with bkmr" />
<meta name="keywords" content="rust,work,development,knowledge_management," />


<meta property="og:title" content="bkmr reborn" />
<meta property="og:description" content="Streamlining Developer Productivity with bkmr" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/bkmr-reborn/" /><meta property="og:image" content="images/share.png"/><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2025-08-11T00:00:00+00:00" />
<meta property="article:modified_time" content="2025-08-11T00:00:00+00:00" /><meta property="og:site_name" content="sysid blog" />



<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="images/share.png"/>

<meta name="twitter:title" content="bkmr reborn"/>
<meta name="twitter:description" content="Streamlining Developer Productivity with bkmr"/>



<meta itemprop="name" content="bkmr reborn">
<meta itemprop="description" content="Streamlining Developer Productivity with bkmr"><meta itemprop="datePublished" content="2025-08-11T00:00:00+00:00" />
<meta itemprop="dateModified" content="2025-08-11T00:00:00+00:00" />
<meta itemprop="wordCount" content="1942"><meta itemprop="image" content="images/share.png"/>
<meta itemprop="keywords" content="rust,work,development,knowledge_management," />
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
    overflow-x: auto;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #333;
      color: #ddd;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #eee;
    }

    a {
      color: #8cc2dd;
    }

    code {
      background-color: #777;
    }

    pre code {
      color: #ddd;
    }

    blockquote {
      color: #ccc;
    }

    textarea,
    input {
      background-color: #252525;
      color: #ddd;
    }

    .helptext {
      color: #aaa;
    }
  }

</style>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-8VH574W51S"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-8VH574W51S', { 'anonymize_ip': false });
}
</script>


</head>

<body>
  <header><a href="/" class="title">
  <h2>sysid blog</h2>
</a>
<nav><a href="/">Home</a>

<a href="/tools">Tools</a>


<a href="/blog">Blog</a>

</nav>
</header>
  <main>

<h1>bkmr reborn</h1>
<p>
  <i>
    <time datetime='2025-08-11' pubdate>
      11 Aug, 2025
    </time>
  </i>
</p>

<content>
  <h1 id="streamlining-developer-productivity">Streamlining Developer Productivity</h1>
<blockquote>
<p>Store it, find it, act on it.</p>
</blockquote>
<p>Developers know the struggle: You&rsquo;re deep into concentration when suddenly you need that
specific command, website, or snippet you used weeks ago.</p>
<p>However, what should have been a quick retrieval turns into a disruptive search.</p>
<p>There are many tools, which individually address this issue. But rarely provide a holistic solution.</p>
<h2 id="the-challenge">The Challenge</h2>
<p>We face a common set of challenges when working with information:</p>
<ol>
<li><strong>Fragmentation</strong>: Information scattered across bookmarks, notes, documentation, and code snippets</li>
<li><strong>Context Switching</strong>: Productivity loss from navigating between different tools and interfaces</li>
<li><strong>Retrieval Friction</strong>: Difficulty in quickly finding the right information at the moment of need</li>
</ol>
<p>At its core, the problem isn&rsquo;t storage or retrieval — it&rsquo;s the friction caused by context
switching. Each interruption, even brief, pulls you out of the productive flow state, disrupting
your thought process.</p>
<p>Many tools today often focus narrowly, forcing developers into multiple contexts. A bookmark
manager might store useful URLs but lacks actionable snippets or shell commands. Snippet tools
might be great for repetitive code but ignore crucial documentation or action capabilities.</p>
<h2 id="a-unified-model-many-formats">A unified model, many formats</h2>
<p>One of bkmr’s biggest strengths is its ability to handle <strong>multiple content types</strong> in a
context-aware way.</p>
<p>Under the hood, <a href="https://github.com/sysid/bkmr">bkmr</a> treats knowledge items consistently — content, metadata, classification,
action — so you use <strong>one</strong> mental model for many formats: bookmarks, snippets, shell scripts, Markdown
docs, plain text, env blocks, and file references.</p>
<p>That uniformity matters because each type comes with a sensible default action (open, copy,
execute, render, print), closing the gap between “found it” and “use it” .</p>
<ul>
<li>
<p><strong>Web Bookmarks:</strong> Save URLs with automatic metadata extraction (title, description, etc.) for
rich context. You can tag bookmarks and instantly open them in your browser via the CLI or fuzzy
search interface. This replaces the need for browser bookmark collections by giving you a
searchable, tagged repository of links.</p>
</li>
<li>
<p><strong>Code Snippets:</strong> Store code blocks or commands as <em>snippets</em> that you can quickly retrieve and
reuse. Snippets are stored with tags and descriptions, and bkmr’s default action will copy a
snippet’s content to your clipboard for easy pasting. This means no more hunting through gists or
scattered files for that piece of code – your personal snippet library is always at hand.</p>
</li>
<li>
<p><strong>Shell Scripts &amp; Commands:</strong> Record shell scripts or one-liner commands as entries in bkmr. When
you search and select a shell script entry, bkmr launches it in an <strong>interactive execution
mode</strong> so you can review or edit the command before running. This turns bkmr into a mini automation
library – you might never need to maintain separate shell script files or remember complex command
invocations again. You can even generate shell function stubs for each script entry, letting you
call them directly in your terminal as if they were regular commands.</p>
</li>
<li>
<p><strong>Markdown Notes &amp; Documents:</strong> Keep your technical notes, documentation, or README files in bkmr
as Markdown entries. bkmr can either store the Markdown content or reference local <code>.md</code> files,
and it provides a built-in <strong>Markdown viewer</strong>: using the <code>bkmr open</code> command on a Markdown entry
launches a browser-based preview with an interactive table of contents and syntax highlighting.
This makes bkmr a lightweight alternative to wikis or note-taking apps – you can jot down
architecture notes, TODO lists, or code review comments in Markdown and instantly render or search
them when needed.</p>
</li>
<li>
<p><strong>Plain Text &amp; Templates:</strong> Save arbitrary text (like config file snippets, JSON/YAML fragments,
or template strings) in bkmr. The tool supports Jinja-style template interpolation in text and
URL entries, meaning your snippets can include dynamic placeholders or shell command results. For
example, a snippet could include <code>{{ \&quot;pwd\&quot; | shell }}</code> to insert the current directory path upon
use. This dynamism goes beyond static snippet managers, letting you create templates that are
<em>processed at insertion time</em>.</p>
</li>
<li>
<p><strong>Environment Variables/Configs:</strong> You can secure your environment setup by storing blocks of
environment variable exports as a special “env” type in bkmr. Retrieving an env entry will print
its content to stdout, ready to be sourced in your shell. This provides a convenient way to manage
environment configurations for different projects or contexts without maintaining separate <code>.env</code>
files.</p>
</li>
<li>
<p><strong>Local Files &amp; Directories:</strong> bkmr can hold references to important files or folders
and open it with the default application. This works great for quick access to design docs,
spreadsheets, or any resource outside your code editor.</p>
</li>
</ul>
<p>All these items are stored in bkmr’s <strong>local SQLite database</strong>  with a unified tagging
system and rich metadata. Because everything lives in one searchable place, <a href="https://github.com/sysid/bkmr">bkmr</a> effectively breaks
down information silos and provides <strong>one consistent interface</strong>.</p>
<h2 id="powerful-search-and-retrieval">Powerful Search and Retrieval</h2>
<p>At the heart of <a href="https://github.com/sysid/bkmr">bkmr</a> is a powerful search engine that ensures you can retrieve any saved item
quickly. By default, bkmr supports both <strong>full-text search</strong> and <strong>advanced filtering by
tags</strong> to narrow results. For example, you can tag items by technology or project (“python”,
“security”, “projectX”) and then search within those tags for specific keywords. The search is
designed to be fuzzy-friendly as well: you can perform quick fuzzy matches across all your content,
and bkmr offers an interactive fzf selector so you can pick the desired result if multiple
items match.</p>
<p>bkmr’s search capabilities are enhanced by optional <strong>semantic search</strong> integration. If enabled,
bkmr can generate semantic embeddings (vector representations) of your content and use an
OpenAI-powered API to find items by conceptual similarity.</p>
<p>Beyond just finding items, bkmr excels at letting you <strong>act on the results quickly</strong>. If your
search yields exactly one result, bkmr will automatically perform that item’s default action for
you. For instance, search for a unique bookmark and it will launch in your browser immediately, or
search a unique shell snippet and it will drop you into the interactive execute mode straightaway.</p>
<p>Even when multiple results are found, the fzf-based picker shows a preview of
each item’s content/metadata and hints about possible actions.</p>
<p>Moreover, <a href="https://github.com/sysid/bkmr">bkmr</a> can output results as JSON for piping to other tools, and since
everything resides in a SQLite database, advanced users can run SQL queries or utilize the data
programmatically. In essence, bkmr combines the speed of fuzzy finders with the
precision of database queries.</p>
<h3 id="tag-based-filtering-with-prefix-support">Tag-Based Filtering with Prefix Support</h3>
<p>The tag prefix system enables powerful, composble search patterns:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#888"># Search for snippets related to authentication, excluding imported content</span>
</span></span><span style="display:flex;"><span>bkmr search --tags-prefix snippet --ntags auth --Ntags-prefix imported
</span></span></code></pre></div><p>This prefix system allows developers to:</p>
<ol>
<li>Create consistent search contexts (e.g., always excluding certain content types)</li>
<li>Combine multiple tag filters to narrow results precisely</li>
<li>Build specialized search functions for different domains</li>
</ol>
<p>For example, a developer might create aliases for different work contexts:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#888"># Project-specific knowledge</span>
</span></span><span style="display:flex;"><span><span style="color:#038">alias</span> proj-api=<span style="color:#d20;background-color:#fff0f0">&#34;bkmr search --tags-prefix project,api --fzf&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888"># Language-specific snippets</span>
</span></span><span style="display:flex;"><span><span style="color:#038">alias</span> py-snippets=<span style="color:#d20;background-color:#fff0f0">&#34;bkmr search --tags-prefix snippet,python --fzf&#34;</span>
</span></span></code></pre></div><h3 id="full-text-search-with-column-specificity">Full-Text Search with Column Specificity</h3>
<p>Beyond tags, <a href="https://github.com/sysid/bkmr">bkmr</a> implements powerful full-text search with column-specific queries.
It builds upon sqlite&rsquo;s mature FTS5 capabilities:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#888"># Find bookmarks with &#34;authentication&#34; in the metadata column</span>
</span></span><span style="display:flex;"><span>bkmr search <span style="color:#d20;background-color:#fff0f0">&#34;metadata:authentication&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888"># Find shell commands related to Docker in the description</span>
</span></span><span style="display:flex;"><span>bkmr search <span style="color:#d20;background-color:#fff0f0">&#34;desc:docker tags:command&#34;</span>
</span></span></code></pre></div><h3 id="semantic-search-integration">Semantic Search Integration</h3>
<p>For cases where keyword matching falls short, bkmr offers semantic search capabilities powered by AI embeddings:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#888"># Find content semantically related to &#34;handling API rate limits&#34;</span>
</span></span><span style="display:flex;"><span>bkmr semsearch <span style="color:#d20;background-color:#fff0f0">&#34;handling API rate limits&#34;</span>
</span></span></code></pre></div><p>This search mode understands conceptual relationships beyond exact text matching, helping
to find knowledge even when the exact terms are not remembered.</p>
<h2 id="seamless-editor-integration-via-lsp-and-plugins">Seamless Editor Integration via LSP and Plugins</h2>
<p>A standout feature of <a href="https://github.com/sysid/bkmr">bkmr</a> is how it brings your curated knowledge into your editor/IDE.
This is achieved through the <strong>bkmr Language Server (bkmr lsp)</strong> and dedicated editor plugins that
leverage it. The bkmr LSP implements the Language Server Protocol for snippet completions, allowing
any LSP-compatible editor (VS Code, Neovim, Emacs, etc.) to access bkmr’s snippet library in real
time (<a href="https://github.com/sysid/bkmr?tab=readme-ov-file#built-in-lsp-server">Built-in LSP server</a>).</p>
<p>Crucially, bkmr lsp <strong>delivers processed snippet content, not just static text</strong>. This means if
your snippet contained a template (say, a placeholder for the current date or output of a command),
the LSP will interpolate or execute it and insert the final result directly into your code. Such
dynamic snippet expansion goes beyond typical IDE “live templates,” effectively giving you
context-aware code generation on the fly (<a href="https://github.com/sysid/bkmr/blob/main/docs/interpolation.md">server-side interpolation</a>).</p>
<h3 id="special-ide-support">Special IDE support</h3>
<ul>
<li>
<p><a href="https://github.com/sysid/bkmr-nvim">bkmr-nvim</a>: visual snippet browsing, rich editing, optional
Telescope/FZF integration, and automatic LSP setup—zero configuration if you want it that way.</p>
</li>
<li>
<p><a href="https://github.com/sysid/bkmr-intellij-plugin">IntelliJ Platform plugin</a>: automatic snippet
completion across JetBrains IDEs, Tab/Shift-Tab placeholder navigation, and a neat “insert
filepath as comment” action that detects the right comment syntax for 20+ file types.</p>
</li>
</ul>
<h2 id="seamless-workflow-integration">Seamless Workflow Integration</h2>
<h3 id="adding-data">Adding data</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#888"># Add a bookmark with automatic metadata extraction</span>
</span></span><span style="display:flex;"><span>bkmr add https://useful-docs.com
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888"># Add a code snippet interactively</span>
</span></span><span style="display:flex;"><span>bkmr add -t snippet -e
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888"># Add a shell command for execution</span>
</span></span><span style="display:flex;"><span>bkmr add <span style="color:#d20;background-color:#fff0f0">&#34;docker run --rm -it -v </span><span style="color:#080;font-weight:bold">$(</span><span style="color:#038">pwd</span><span style="color:#080;font-weight:bold">)</span><span style="color:#d20;background-color:#fff0f0">:/app node:16&#34;</span> -t <span style="color:#038">command</span>
</span></span></code></pre></div><h3 id="actionable-knowledge">Actionable Knowledge</h3>
<p>Beyond retrieval, <a href="https://github.com/sysid/bkmr">bkmr</a> ensures that each item becomes immediately actionable:</p>
<ul>
<li>Snippets instantly copy to the clipboard, facilitating immediate use.</li>
<li>Shell commands can be executed straight from the interface, dramatically reducing repetitive manual typing.</li>
<li>URLs launch directly into a browser from the command line.</li>
<li>Markdown is directly rendered in the browser with automatic TOC.</li>
</ul>
<h3 id="interactive-interface">Interactive Interface</h3>
<p>The fuzzy finder interface enables rapid narrowing of results:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#888"># Search with interactive fuzzy finder</span>
</span></span><span style="display:flex;"><span>bkmr search --fzf <span style="color:#d20;background-color:#fff0f0">&#34;docker&#34;</span>
</span></span></code></pre></div><p>Within this interface, developers can:</p>
<ul>
<li>Preview full content before selection</li>
<li>Use keyboard shortcuts for common actions (open, edit, delete)</li>
<li>Filter results dynamically as they type</li>
</ul>
<h3 id="multiple-databases">Multiple Databases</h3>
<p>Developers can maintain separate databases for different contexts:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#888"># Personal knowledge base</span>
</span></span><span style="display:flex;"><span><span style="color:#038">alias</span> bkmr-personal=<span style="color:#d20;background-color:#fff0f0">&#34;BKMR_DB_URL=</span><span style="color:#369">$HOME</span><span style="color:#d20;background-color:#fff0f0">/.config/bkmr/personal.db bkmr&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888"># Work-specific database</span>
</span></span><span style="display:flex;"><span><span style="color:#038">alias</span> bkmr-work=<span style="color:#d20;background-color:#fff0f0">&#34;BKMR_DB_URL=</span><span style="color:#369">$HOME</span><span style="color:#d20;background-color:#fff0f0">/.config/bkmr/work.db bkmr&#34;</span>
</span></span></code></pre></div><p>This provides appropriate isolation while maintaining a consistent interface.</p>
<h3 id="integration-with-other-tools">Integration with Other Tools</h3>
<p>bkmr works seamlessly with other CLI tools:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#888"># Process results with jq</span>
</span></span><span style="display:flex;"><span>bkmr search --json <span style="color:#d20;background-color:#fff0f0">&#34;api&#34;</span> | jq <span style="color:#d20;background-color:#fff0f0">&#39;.[] | .url&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#888"># Combine with directory navigation</span>
</span></span><span style="display:flex;"><span>proj() {
</span></span><span style="display:flex;"><span>    <span style="color:#038">pushd</span> ~/projects/<span style="color:#369">$1</span> &amp;&amp; bkmr search --tags <span style="color:#d20;background-color:#fff0f0">&#34;project-</span><span style="color:#369">$1</span><span style="color:#d20;background-color:#fff0f0">&#34;</span> --fzf
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="replacements">Replacements</h2>
<p>Here are examples of what <strong>bkmr</strong> could replace in a developer’s toolkit:</p>
<ul>
<li>
<p><strong>Browser Bookmark Managers:</strong> Instead of storing development-related links in your browser (or
tools like Pocket/Raindrop), bkmr lets you save them with richer context (tags, descriptions) and
find them via CLI. Because bkmr is terminal-based, you can open links without ever taking your
hands off the keyboard.</p>
</li>
<li>
<p><strong>Standalone Snippet Managers and IDE Snippets:</strong> Traditional snippet manager apps or
editor-specific snippet configurations become unnecessary. bkmr provides a unified snippet
repository accessible from <strong>any editor</strong> through LSP, so you no longer need to maintain separate
snippets in VS Code, Vim, and IntelliJ – all use the same source. Moreover, bkmr’s support for
dynamic content (like the template interpolation and shell command execution) goes beyond static
text expansions offered by typical IDE snippet tools.</p>
</li>
<li>
<p><strong>Note-Taking and Markdown Knowledge Bases:</strong> Many developers keep README files, design docs, or
troubleshooting notes scattered in folders or in apps like Evernote/Notion. With bkmr, you can
consolidate all those Markdown notes into a single system with full-text and semantic search. The
built-in Markdown renderer with table of contents makes reading long notes comfortable.</p>
</li>
<li>
<p><strong>CLI Cheat Sheets and Task Runners:</strong> Developers often rely on command cheat-sheet tools (like
<code>tldr</code> or personal scripts) and maintain collections of shell scripts for repetitive tasks. bkmr
rolls these use cases into one: you store your commands with descriptions and then invoke them via
fuzzy search or shell stub functions. It’s like having a customized <code>tldr</code> that only contains the
commands relevant to you.</p>
</li>
</ul>
<p>bkmr reduces the mental overhead of remembering where things are saved and which tool to use.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The most valuable developer tools are those that fade into the background, removing obstacles
rather than creating new ones.</p>
<p><a href="https://github.com/sysid/bkmr">bkmr</a> tries to achieve this by addressing a fundamental challenge: storing information, finding it
and enabling immediate action.</p>
<p><strong>Minimize Disruption</strong>!</p>

</content>
<p>
  
  <a href="/blog/rust/">#rust</a>
  
  <a href="/blog/work/">#work</a>
  
  <a href="/blog/development/">#development</a>
  
  <a href="/blog/knowledge_management/">#knowledge_management</a>
  
</p>

  </main>
  <footer>
</footer>

    
</body>

</html>
